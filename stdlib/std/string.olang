// --- Standard Library Interface ---
// External C functions
fn strlen(str: *byte) -> int;
fn memcpy(dest: *byte, src: *byte, n: int) -> *void;
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);
fn printf(str: *byte);

// --- The String Class ---
struct String {
    buffer: byte[]; // Dynamic Array (Slice)
    length: int;    // Current text length
    // capacity is now implicit in buffer.len

    // Constructor: Creates a String from a C-style string literal
    new(ptr: *char) {
        var len = 0;
        unsafe {
            len = strlen(ptr);
        }

        this.length = len;
        
        // Allocate managed array (slice)
        // Capacity is len + 1 for null terminator
        this.buffer = new byte[len + 1];

        unsafe {
            // Use external memcpy using the raw pointer from the slice
            memcpy(this.buffer.ptr, ptr, len);

            // Null terminate
            this.buffer[len] = 0;
        }
    }

    // Constructor: Creates an empty string with reserved capacity
    new(cap: int) {
        this.length = 0;
        var actual_cap = cap;
        if (actual_cap < 1) {
            actual_cap = 1;
        }

        this.buffer = new byte[actual_cap];
        unsafe {
            this.buffer[0] = 0;
        }
    }

    fn append(str: *String) {
        var required_len = this.length + str.length;

        // Check capacity using .len
        if (required_len >= this.buffer.len) {
            var new_cap = required_len * 2;
            if (new_cap < 16) { new_cap = 16; }

            // Create new buffer
            var new_buf = new byte[new_cap];

            unsafe {
                // Copy old data
                memcpy(new_buf.ptr, this.buffer.ptr, this.length);
            }
            
            // Replace buffer
            this.buffer = new_buf;
        }

        unsafe {
            // Append new data
            // Calculate destination address using pointer arithmetic
            var dest_ptr = this.buffer.ptr + this.length;
            memcpy(dest_ptr, str.buffer.ptr, str.length);

            this.length = required_len;
            this.buffer[this.length] = 0;
        }
    }

    fn c_str() -> *byte {
        return this.buffer.ptr;
    }

    // Operator Overloading: +
    fn op_add(other: *String) -> *String {
        var new_len = this.length + other.length;
        
        // Create result with enough capacity
        var result = new String(new_len + 1);
        result.length = new_len;

        unsafe {
            // Copy this
            memcpy(result.buffer.ptr, this.buffer.ptr, this.length);

            // Copy other
            var dest = result.buffer.ptr + this.length;
            memcpy(dest, other.buffer.ptr, other.length);

            // Null terminate
            result.buffer[new_len] = 0;
        }

        return result;
    }

    fn op_index(idx: int) -> int {
        // Use safe slice indexing
        return this.buffer[idx];
    }
}
