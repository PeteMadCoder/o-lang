// External C functions
import "memory.olang";

fn exit(status: int);

// --- The Vector Class ---
// A dynamic vector implementation that resizes as needed
struct Vector<T> {
    data: *T;      // Pointer to dynamically allocated array
    count: int;    // Number of elements currently in vector
    capacity: int; // Total allocated capacity

    // Constructor: Creates an empty vector with initial capacity
    new() {
        this.capacity = 4;  // Start with small capacity
        this.count = 0;
        // Allocate initial buffer
        unsafe {
            this.data = malloc(this.capacity * 4) as *T;  // Assuming T is int-sized
        }
    }

    fn push(val: T) {
        // Check if we need to resize
        if (this.count >= this.capacity) {
            // Double the capacity
            var old_capacity = this.capacity;
            this.capacity = this.capacity * 2;

            // Allocate new buffer
            var new_data: *T;
            unsafe {
                new_data = malloc(this.capacity * 4) as *T;  // Assuming T is int-sized
            }

            // Copy existing elements to new buffer
            var i = 0;
            while (i < this.count) {
                unsafe {
                    *(new_data + i) = *(this.data + i);
                }
                i = i + 1;
            }

            // Free old buffer
            unsafe {
                free(this.data as *byte);
            }

            // Update data pointer
            this.data = new_data;
        }

        // Add the new element
        unsafe {
            *(this.data + this.count) = val;
        }
        this.count = this.count + 1;
    }

    fn pop() -> T {
        if (this.count <= 0) {
            unsafe {
                exit(1); // Vector is empty
            }
        }

        this.count = this.count - 1;
        unsafe {
            return *(this.data + this.count);
        }
    }

    // Operator Overloading for Indexing
    fn op_index(idx: int) -> T {
        if (idx >= this.count || idx < 0) {
            unsafe {
                exit(1); // Bounds check
            }
        }
        unsafe {
            return *(this.data + idx);
        }
    }

    fn size() -> int {
        return this.count;
    }

    fn is_empty() -> bool {
        return this.count == 0;
    }

    fn full() -> bool {
        return false; // Dynamic vector never gets "full" in the traditional sense
    }
}