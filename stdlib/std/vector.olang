// External C functions for memory management
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);

// --- The Vector Class ---
struct Vector<T> {
    data: *byte;   // Pointer to dynamically allocated array (as byte array)
    size: int;     // Number of elements currently in vector
    capacity: int; // Total allocated capacity (number of elements)

    // Constructor: Creates an empty vector with initial capacity
    new() {
        this.capacity = 4;  // Start with small capacity
        this.size = 0;
        // Allocate initial buffer: capacity * 4 bytes (assuming T is int-sized)
        this.data = malloc(this.capacity * 4);
    }

    fn push(val: T) {
        // Inline resize logic to avoid method call
        if (this.size >= this.capacity) {
            var old_capacity = this.capacity;
            this.capacity = this.capacity * 2;  // Double the capacity

            // Allocate new buffer
            var new_data = malloc(this.capacity * 4);

            // Copy existing elements to new buffer using manual byte copy
            unsafe {
                var i = 0;
                var bytes_to_copy = this.size * 4;  // 4 bytes per element
                while (i < bytes_to_copy) {
                    var src_addr = this.data + i;
                    var dst_addr = new_data + i;
                    *dst_addr = *src_addr;
                    i = i + 1;
                }
            }

            // Free old buffer
            free(this.data);

            // Update data pointer
            this.data = new_data;
        }

        // Add the new element by calculating byte offset
        unsafe {
            var element_size = 4;  // Assuming 4 bytes per element (int)
            var byte_offset = this.size * element_size;
            var base_ptr = this.data as *int;  // Cast to int pointer for offset calculation
            var element_addr = base_ptr + this.size;  // This will multiply by sizeof(int)
            *element_addr = val;
        }
        this.size = this.size + 1;
    }

    // Operator Overloading for Indexing
    fn op_index(idx: int) -> T {
        if (idx >= this.size || idx < 0) {
            // For now, return a default value instead of exiting
            return 0;  // This is a simplification
        }

        unsafe {
            // Cast data pointer to int* type for proper indexing
            var base_ptr = this.data as *int;
            var element_ptr = base_ptr + idx;  // This will multiply by sizeof(int)
            return *element_ptr;
        }
    }

    fn size() -> int {
        return this.size;
    }
}