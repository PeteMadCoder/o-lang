// External C memory functions
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);
fn memcpy(dest: *byte, src: *byte, n: int) -> *void;
fn memset(ptr: *byte, value: int, n: int) -> *void;
fn memcmp(ptr1: *byte, ptr2: *byte, n: int) -> int;

// Memory allocation wrappers
fn alloc(size: int) -> *byte {
    unsafe {
        return malloc(size);
    }
}

fn dealloc(ptr: *byte) {
    unsafe {
        free(ptr);
    }
}

// Memory manipulation functions
fn copy(dest: *byte, src: *byte, size: int) {
    unsafe {
        memcpy(dest, src, size);
    }
}

fn set(ptr: *byte, value: int, size: int) {
    unsafe {
        memset(ptr, value, size);
    }
}

fn zero(ptr: *byte, size: int) {
    unsafe {
        memset(ptr, 0, size);
    }
}

fn compare(ptr1: *byte, ptr2: *byte, size: int) -> int {
    unsafe {
        return memcmp(ptr1, ptr2, size);
    }
}

// Safe memory operations with bounds checking
fn safe_copy(dest: *byte, dest_size: int, src: *byte, copy_size: int) -> bool {
    if (copy_size > dest_size) {
        return false;
    }
    copy(dest, src, copy_size);
    return true;
}

fn safe_set(ptr: *byte, buffer_size: int, value: int, set_size: int) -> bool {
    if (set_size > buffer_size) {
        return false;
    }
    set(ptr, value, set_size);
    return true;
}

// Memory utilities
// fn is_aligned(ptr: *byte, alignment: int) -> bool {
//     unsafe {
//         var addr = ptr;
//         var remainder = addr % alignment;
//         return remainder == 0;
//     }
// }

fn align_up(size: int, alignment: int) -> int {
    var remainder = size % alignment;
    if (remainder == 0) {
        return size;
    }
    return size + (alignment - remainder);
}
