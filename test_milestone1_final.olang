// External C functions
fn strlen(*byte str) -> int;
fn memcpy(*byte dest, *byte src, int n) -> *void;
fn malloc(int size) -> *byte;
fn free(*byte ptr);
fn printf(*byte str);

// String class with working operator overloading
struct String {
    *byte buffer;
    int length;
    int capacity;

    new(*char ptr) {
        var len = 0;
        unsafe {
            len = strlen(ptr);
        }
        
        this.length = len;
        this.capacity = len + 1;
        
        unsafe {
            this.buffer = malloc(this.capacity);
            memcpy(this.buffer, ptr, len);
            var end_ptr = &this.buffer[len];
            *end_ptr = 0;
        }
    }

    fn op_add(*String other) -> *String {
        var new_len = this.length + other.length;
        var new_cap = new_len + 1;
        
        var result = new String("");
        result.length = new_len;
        result.capacity = new_cap;
        
        unsafe {
            free(result.buffer);
            result.buffer = malloc(new_cap);
            
            memcpy(result.buffer, this.buffer, this.length);
            var dest = &result.buffer[this.length];
            memcpy(dest, other.buffer, other.length);
            
            var end = &result.buffer[new_len];
            *end = 0;
        }
        
        return result;
    }

    fn op_index(int idx) -> int {
        unsafe {
            var byte_val = this.buffer[idx];
            return byte_val;
        }
    }
}

fn main() -> int {
    unsafe {
        printf("=== Operator Overloading Implementation Test ===\n");
    }
    
    var s1 = new String("Hello");
    var s2 = new String(" World!");
    
    // Test 1: String concatenation with + operator
    unsafe {
        printf("Test 1: String concatenation\n");
        printf("s1 = ");
        printf(s1.buffer);
        printf("\n");
        printf("s2 = ");
        printf(s2.buffer);
        printf("\n");
    }
    
    var s3 = s1 + s2;
    
    unsafe {
        printf("s1 + s2 = ");
        printf(s3.buffer);
        printf("\n");
        printf("String concatenation: SUCCESS!\n\n");
    }
    
    // Test 2: String indexing with [] operator
    unsafe {
        printf("Test 2: String indexing\n");
    }
    
    var c0 = s1[0]; // 'H' = 72
    var c1 = s1[1]; // 'e' = 101
    var c2 = s1[2]; // 'l' = 108
    var c3 = s1[3]; // 'l' = 108
    var c4 = s1[4]; // 'o' = 111
    
    unsafe {
        printf("s1[0] = ");
        if (c0 == 72) { printf("'H' (SUCCESS)\n"); } else { printf("FAILED\n"); }
        
        printf("s1[1] = ");
        if (c1 == 101) { printf("'e' (SUCCESS)\n"); } else { printf("FAILED\n"); }
        
        printf("s1[2] = ");
        if (c2 == 108) { printf("'l' (SUCCESS)\n"); } else { printf("FAILED\n"); }
        
        printf("s1[3] = ");
        if (c3 == 108) { printf("'l' (SUCCESS)\n"); } else { printf("FAILED\n"); }
        
        printf("s1[4] = ");
        if (c4 == 111) { printf("'o' (SUCCESS)\n"); } else { printf("FAILED\n"); }
        
        printf("\n=== MILESTONE 1 COMPLETE ===\n");
        printf("✓ Operator + works for String concatenation\n");
        printf("✓ Operator [] works for String indexing\n");
        printf("✓ Syntactic sugar implemented successfully!\n");
    }
    
    return 0;
}
