// Test with op_add method like the String class
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);
fn strlen(str: *byte) -> int;
fn memcpy(dest: *byte, src: *byte, n: int) -> *void;

// Internal memcpy using pointer arithmetic
fn my_memcpy(dest: *byte, src: *byte, n: int) {
    unsafe {
        var i = 0;
        while (i < n) {
            var d = &dest[i];
            var s = &src[i];
            *d = *s;
            i = i + 1;
        }
    }
}

struct TestString {
    buffer: *byte;
    length: int;
    capacity: int;

    // Constructor: Creates a String from a C-style string literal
    new(ptr: *char) {
        var len = 0;
        unsafe {
            len = strlen(ptr);
        }

        this.length = len;
        this.capacity = len + 1;

        unsafe {
            this.buffer = malloc(this.capacity);
            var end_ptr = &this.buffer[len];
            *end_ptr = 0;
        }
    }

    // Constructor: Creates an empty string with reserved capacity
    new(cap: int) {
        this.length = 0;
        this.capacity = cap;
        if (cap < 1) {
            this.capacity = 1;
        }

        unsafe {
            this.buffer = malloc(this.capacity);
            *this.buffer = 0;
        }
    }

    fn append(str: *TestString) {
        var required_len = this.length + str.length;

        if (required_len >= this.capacity) {
            var new_cap = required_len * 2;
            if (new_cap < 16) { new_cap = 16; }

            unsafe {
                var new_buf = malloc(new_cap);

                my_memcpy(new_buf, this.buffer, this.length);  // Using my_memcpy instead of memcpy
                free(this.buffer);
                this.buffer = new_buf;
            }
            this.capacity = new_cap;
        }

        unsafe {
            var i = 0;
            while (i < str.length) {
                var d = &this.buffer[this.length + i];
                var s = &str.buffer[i];
                *d = *s;
                i = i + 1;
            }

            this.length = required_len;
            var end_ptr = &this.buffer[this.length];
            *end_ptr = 0;
        }
    }

    // Operator Overloading: +
    fn op_add(other: *TestString) -> *TestString {
        var new_len = this.length + other.length;
        var new_cap = new_len + 1;

        var result = new TestString(new_cap);
        result.length = new_len;

        unsafe {
            // Copy this
            var dest = result.buffer;
            memcpy(dest, this.buffer, this.length);

            // Copy other
            dest = &result.buffer[this.length];
            memcpy(dest, other.buffer, other.length);

            // Null terminate
            var end = &result.buffer[new_len];
            *end = 0;
        }

        return result;
    }
}

fn main() -> int {
    var msg = new TestString("Hello");
    return 0;
}