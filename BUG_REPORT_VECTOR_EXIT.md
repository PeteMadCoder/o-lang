# Bug Report: Compiler Crash on External Function Calls in Deferred Generic Instantiation

**Severity:** Critical  
**Status:** Open  
**Date:** January 12, 2026  
**Component:** Code Generation (Deferred Instantiation / Imports)

## Summary
The compiler terminates with a **Segmentation Fault (Signal 139)** during the deferred instantiation of a generic struct's method if that method calls an external function (like `exit`) that **has not been previously used** in the main compilation unit.

Functions that are used in the main body (like `malloc`, which is implicitly called by `new`) work correctly when called from within generic methods. This suggests a symbol initialization or linkage issue for external declarations that are exclusively referenced by generic code.

## Reproduction Steps

### 1. Minimal Test Case
Create two files: `lib.olang` (defining the external function) and `main.olang` (instantiating the generic).

**File: `lib.olang`**
```olang
// Declare external function (no body)
fn my_exit(status: int);

struct Box<T> {
    val: T;
    
    fn do_exit() {
        // Crash happens here during instantiation
        my_exit(1); 
    }
}
```

**File: `main.olang`**
```olang
import "lib.olang";

fn main() -> int {
    // Instantiate Box<int>.
    // Note: my_exit() is NOT called in main(), only inside Box.
    var b = new Box<int>();
    b.do_exit();
    return 0;
}
```

### 2. Command
```bash
./oc main.olang -o test.obj
```

### 3. Output
```text
Compiling: main.olang
...
Processing Deferred Item: Box_int
  Generating method: do_exit
Segmentation fault (core dumped)
```

## Technical Analysis

### Stack Trace / Location
The crash occurs in `o-compiler/src/codegen/ExpressionCodeGen.cpp`, specifically within `codegen(CallExprAST &E)`.
The instruction causing the crash is the LLVM `CreateCall`:
```cpp
return codeGen.Builder->CreateCall(CalleeF->getFunctionType(), CalleeF, ArgsV, "calltmp");
```

### Observations
1.  **Pointer Validity:** Debug prints confirm that `CalleeF` (pointer to `my_exit`), `TheContext`, `TheModule`, and `Builder` are **all valid non-null pointers** immediately before the crash.
2.  **Module Presence:** `CalleeF` is found within `TheModule` (via `getFunction`).
3.  **Argument Types:** Explicit type casting was implemented to ensure `ArgsV` types match `CalleeF->getFunctionType()`, ruling out simple type mismatches (e.g., `i64` vs `i32`).
4.  **Correlation with Usage:**
    *   **Works:** `malloc` works inside generic methods. This correlates with `malloc` being generated by `NewExprAST` in `main()` *before* the deferred generic pass runs.
    *   **Fails:** `exit` (or `my_exit`) fails inside generic methods. This correlates with `exit` *not* being used in `main()`.

### Hypothesized Root Cause
**"Lazy Declaration" Instability:**
When an external function is imported but not used in the main AST, its LLVM `Function*` might be created in a transient or incomplete state during the import pass. 
- If `main` uses it, the function is "concretized" or properly initialized in the module.
- If only the deferred generic pass uses it, the compiler attempts to call a function definition that might be stale, belong to a released context (from the import parsing phase), or have a corrupted internal LLVM representation despite the pointer looking valid.

## Suggested Fix Approach
Investigate `FunctionCodeGen` and `CompilerDriver` logic regarding imported external prototypes.
1.  Ensure that **all** imported function prototypes are fully declared in the main `llvm::Module` before code generation begins, or...
2.  In `processDeferredInstantiations`, ensure that looking up a function via `GlobalFunctionProtos` correctly "revives" or recreates the function declaration in the current `llvm::Module` if it was only present as a prototype or a declaration in a previous/different context.
