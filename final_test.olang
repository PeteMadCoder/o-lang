// External C functions
fn strlen(*byte str) -> int;
fn memcpy(*byte dest, *byte src, int n) -> *void;
fn malloc(int size) -> *byte;
fn printf(*byte str);

struct String {
    *byte buffer;
    int length;

    new(*char ptr) {
        unsafe {
            this.length = strlen(ptr);
            this.buffer = malloc(this.length + 1);
            memcpy(this.buffer, ptr, this.length);
            var end_ptr = &this.buffer[this.length];
            *end_ptr = 0;
        }
    }

    fn op_add(*String other) -> *String {
        var new_len = this.length + other.length;
        var result = new String("");
        result.length = new_len;
        
        unsafe {
            var old_buf = result.buffer;
            result.buffer = malloc(new_len + 1);
            
            memcpy(result.buffer, this.buffer, this.length);
            var dest = &result.buffer[this.length];
            memcpy(dest, other.buffer, other.length);
            
            var end = &result.buffer[new_len];
            *end = 0;
        }
        
        return result;
    }

    fn op_index(int idx) -> int {
        unsafe {
            return this.buffer[idx];
        }
    }
}

fn main() -> int {
    unsafe {
        printf("=== MILESTONE 1 COMPLETE ===\n");
    }
    
    var s1 = new String("Hello");
    var s2 = new String(" World!");
    
    // Test both operators
    var s3 = s1 + s2;
    var c = s1[1];
    
    unsafe {
        printf("Concatenation: ");
        printf(s3.buffer);
        printf("\n");
        
        if (c == 101) {
            printf("Indexing: SUCCESS (got 'e')\n");
            printf("ðŸŽ‰ Both operators working!\n");
        } else {
            printf("Indexing: FAILED\n");
        }
    }
    
    return 0;
}
