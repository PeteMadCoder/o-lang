import "std/io.olang";

// External C functions for memory management
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);

// --- The Vector Class - Specific for int type ---
struct IntVector {
    data: *byte;   // Pointer to dynamically allocated array (as byte array)
    size: int;     // Number of elements currently in vector
    capacity: int; // Total allocated capacity (number of elements)

    // Constructor: Creates an empty vector with initial capacity
    new() {
        this.capacity = 4;  // Start with small capacity
        this.size = 0;
        // Allocate initial buffer: capacity * 4 bytes (for int)
        this.data = malloc(this.capacity * 4);
    }

    fn push(val: int) {
        // Inline resize logic to avoid method call
        if (this.size >= this.capacity) {
            var old_capacity = this.capacity;
            this.capacity = this.capacity * 2;  // Double the capacity

            // Allocate new buffer
            var new_data = malloc(this.capacity * 4);

            // Copy existing elements to new buffer using manual byte copy
            unsafe {
                var i = 0;
                var bytes_to_copy = this.size * 4;  // 4 bytes per element
                while (i < bytes_to_copy) {
                    var src_addr = this.data + i;
                    var dst_addr = new_data + i;
                    *dst_addr = *src_addr;
                    i = i + 1;
                }
            }

            // Free old buffer
            free(this.data);

            // Update data pointer
            this.data = new_data;
        }

        // Add the new element by casting to appropriate pointer type
        unsafe {
            // Cast data pointer to int* type for proper indexing
            var typed_ptr = this.data as *int;
            var element_ptr = typed_ptr + this.size;
            *element_ptr = val;
        }
        this.size = this.size + 1;
    }

    // Operator Overloading for Indexing
    fn op_index(idx: int) -> int {
        if (idx >= this.size || idx < 0) {
            // For now, return a default value instead of exiting
            return 0;  // This is a simplification
        }

        unsafe {
            // Cast data pointer to int* type for proper indexing
            var typed_ptr = this.data as *int;
            var element_ptr = typed_ptr + idx;
            return *element_ptr;
        }
    }

    fn size() -> int {
        return this.size;
    }
}

fn main() -> int {
    var vec = new IntVector();

    print_int(vec.size());
    println("");  // Should print 0

    vec.push(42);

    print_int(vec.size());
    println("");  // Should print 1

    var val = vec[0];
    print_int(val);
    println("");  // Should print 42

    return 0;
}