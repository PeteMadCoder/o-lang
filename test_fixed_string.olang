// External C functions
fn strlen(str: *byte) -> int;
fn memcpy(dest: *byte, src: *byte, n: int) -> *void;
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);

// Internal memcpy using pointer arithmetic
fn my_memcpy(dest: *byte, src: *byte, n: int) {
    unsafe {
        var i = 0;
        while (i < n) {
            var d = &dest[i];
            var s = &src[i];
            *d = *s;
            i = i + 1;
        }
    }
}

// --- The String Class ---
struct String {
    buffer: *byte;
    length: int;
    capacity: int;

    // Constructor: Creates a String from a C-style string literal
    new(ptr: *char) {
        var len = 0;
        unsafe {
            // Use external strlen
            len = strlen(ptr);
        }

        this.length = len;
        this.capacity = len + 1;

        unsafe {
            this.buffer = malloc(this.capacity);

            // Use external memcpy.
            memcpy(this.buffer, ptr, len);

            // Null terminate
            var end_ptr = &this.buffer[len];
            *end_ptr = 0;
        }
    }

    // Constructor: Creates an empty string with reserved capacity
    new(cap: int) {
        this.length = 0;
        this.capacity = cap;
        if (cap < 1) {
            this.capacity = 1;
        }

        unsafe {
            this.buffer = malloc(this.capacity);
            *this.buffer = 0;
        }
    }

    fn append(str: *String) {
        // printf(this.buffer);

        var required_len = this.length + str.length;

        if (required_len >= this.capacity) {
            var new_cap = required_len * 2;
            if (new_cap < 16) { new_cap = 16; }

            unsafe {
                var new_buf = malloc(new_cap);

                my_memcpy(new_buf, this.buffer, this.length);
                free(this.buffer);
                this.buffer = new_buf;
            }
            this.capacity = new_cap;
        }

        unsafe {
            var i = 0;
            while (i < str.length) {
                var d = &this.buffer[this.length + i];
                var s = &str.buffer[i];
                *d = *s;
                i = i + 1;
            }

            this.length = required_len;
            var end_ptr = &this.buffer[this.length];
            *end_ptr = 0;
        }
    }

    fn c_str() -> *byte {
        return this.buffer;
    }

    // Operator Overloading: +
    // COMMENTED OUT TO AVOID RECURSIVE INSTANTIATION ISSUES
    /*fn op_add(other: *String) -> *String {
        var new_len = this.length + other.length;
        var new_cap = new_len + 1;

        var result = new String(new_cap);
        result.length = new_len;

        unsafe {
            // Copy this
            var dest = result.buffer;
            memcpy(dest, this.buffer, this.length);

            // Copy other
            dest = &result.buffer[this.length];
            memcpy(dest, other.buffer, other.length);

            // Null terminate
            var end = &result.buffer[new_len];
            *end = 0;
        }

        return result;
    }*/

    fn op_index(idx: int) -> int {
        unsafe {
            var result = this.buffer[idx];
            return result;
        }
    }
}

fn main() -> int {
    var msg = new String("Hello, World!");
    return 0;
}