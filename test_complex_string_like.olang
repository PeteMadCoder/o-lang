// More complex test similar to string implementation
fn malloc(size: int) -> *byte;
fn free(ptr: *byte);
fn memcpy(dest: *byte, src: *byte, n: int) -> *void;

struct ComplexStruct {
    buffer: *byte;
    length: int;
    capacity: int;

    new(len: int) {
        this.length = len;
        this.capacity = len + 1;
        unsafe {
            this.buffer = malloc(this.capacity);
            var end_ptr = &this.buffer[len];
            *end_ptr = 0;
        }
    }

    fn complex_method(other_buffer: *byte, other_len: int) {
        var required_len = this.length + other_len;

        if (required_len >= this.capacity) {
            var new_cap = required_len * 2;
            unsafe {
                var new_buf = malloc(new_cap);
                memcpy(new_buf, this.buffer, this.length);
                free(this.buffer);
                this.buffer = new_buf;
            }
            this.capacity = new_cap;
        }

        unsafe {
            var i = 0;
            while (i < other_len) {
                var d = &this.buffer[this.length + i];
                var s = &other_buffer[i];
                *d = *s;
                i = i + 1;
            }

            this.length = required_len;
            var end_ptr = &this.buffer[this.length];
            *end_ptr = 0;
        }
    }
}

fn main() -> int {
    var s = new ComplexStruct(5);
    return 0;
}